CLEAN_FILES = # deliberately empty, so we can append below.
CFLAGS += ${EXTRA_CFLAGS}
CXXFLAGS += ${EXTRA_CXXFLAGS}
LDFLAGS += $(EXTRA_LDFLAGS)
ARFLAGS = rs
OPT=

# Set the default DEBUG_LEVEL to 0
DEBUG_LEVEL?=0

ifeq ($(MAKECMDGOALS),dbg)
  DEBUG_LEVEL=2 # compatible with rocksdb
endif

ifeq ($(MAKECMDGOALS),all)
  DEBUG_LEVEL=0
endif

ifeq ($(MAKECMDGOALS),clean)
  DEBUG_LEVEL=0
endif

ifeq ($(MAKECMDGOALS),shared_lib)
  DEBUG_LEVEL=0
endif

ifeq ($(MAKECMDGOALS),static_lib)
  DEBUG_LEVEL=0
endif

# compile with -O2 if for release
# if we're compiling for release, compile without debug code (-DNDEBUG) and
# don't treat warnings as errors
ifeq ($(DEBUG_LEVEL),0)
DISABLE_WARNING_AS_ERROR=1
OPT += -O2 -fno-omit-frame-pointer -DNDEBUG
# Skip for archs that don't support -momit-leaf-frame-pointer
ifeq (,$(shell $(CXX) -fsyntax-only -momit-leaf-frame-pointer -xc /dev/null 2>&1))
OPT += -momit-leaf-frame-pointer
endif
else
$(warning Warning: Compiling in debug mode. Don't use the resulting binary in production)
endif

#-----------------------------------------------

include ./src.mk

ifndef ROCKSDB_PATH
$(info rocksdb path is not given, use default: ./rocksdb)
$(info acquiring rocksdb from github, wait...)
dummy := $(git submodule init; git submodule update)
$(info acquire rocksdb from github, done)

ROCKSDB_PATH = $(CURDIR)/rocksdb/
else
$(info NOTICE: ROCKSDB_PATH should be absolute path)
endif
ROCKSDB_PATH = $(CURDIR)/../rocksdb/
$(info $(ROCKSDB_PATH))

LDFLAGS += $(PLATFORM_LDFLAGS)
EXEC_FLAGS += -L$(CURDIR)/lib -L$(ROCKSDB_PATH)/ -lnemodb -lrocksdb

AM_DEFAULT_VERBOSITY = 0

AM_V_GEN = $(am__v_GEN_$(V))
am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 =
AM_V_at = $(am__v_at_$(V))
am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
am__v_at_0 = @
am__v_at_1 =

AM_V_CC = $(am__v_CC_$(V))
am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
am__v_CC_0 = @echo "  CC      " $@;
am__v_CC_1 =
CCLD = $(CC)
LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_CCLD = $(am__v_CCLD_$(V))
am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
am__v_CCLD_0 = @echo "  CCLD    " $@;
am__v_CCLD_1 =
AM_V_AR = $(am__v_AR_$(V))
am__v_AR_ = $(am__v_AR_$(AM_DEFAULT_VERBOSITY))
am__v_AR_0 = @echo "  AR      " $@;
am__v_AR_1 =

AM_LINK = $(AM_V_CCLD)$(CXX) $^ -o $@ $(LDFLAGS) $(EXEC_FLAGS) $(COVERAGEFLAGS)
# detect what platform we're building on
#dummy := $(shell (cd $(ROCKSDB_PATH); export ROCKSDB_ROOT="$(CURDIR)/rocksdb"; "$(CURDIR)/rocksdb/build_tools/build_detect_platform" "$(CURDIR)/make_config.mk"))
dummy := $(shell (cd $(ROCKSDB_PATH); export ROCKSDB_ROOT="$(ROCKSDB_PATH)"; "$(ROCKSDB_PATH)/build_tools/build_detect_platform" "$(CURDIR)/make_config.mk"))
# this file is generated by the previous line to set build flags and sources
include make_config.mk
CLEAN_FILES += make_config.mk

missing_make_config_paths := $(shell        \
  grep "\/\S*" -o $(CURDIR)/make_config.mk |    \
  while read path;          \
    do [ -e $$path ] || echo $$path;    \
  done | sort | uniq)

$(foreach path, $(missing_make_config_paths), \
  $(warning Warning: $(path) dont exist))

CFLAGS += -g
CXXFLAGS += -g

# This (the first rule) must depend on "all".
default: all

WARNING_FLAGS = -W -Wextra -Wall -Wsign-compare \
  -Wno-unused-parameter -Wno-redundant-decls -Wwrite-strings \
	-Wpointer-arith -Wreorder -Wswitch -Wsign-promo \
  -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers

ifndef DISABLE_WARNING_AS_ERROR
  WARNING_FLAGS += -Werror
endif

CFLAGS += $(WARNING_FLAGS) -I. -I$(ROCKSDB_PATH) -I$(ROCKSDB_PATH)include $(PLATFORM_CCFLAGS) $(OPT)
CXXFLAGS += $(WARNING_FLAGS) -I. -I$(ROCKSDB_PATH) -I$(ROCKSDB_PATH)/include $(PLATFORM_CXXFLAGS) $(OPT) 

date := $(shell date +%F)
git_sha := $(shell git rev-parse HEAD 2>/dev/null)
gen_build_version = sed -e s/@@GIT_SHA@@/$(git_sha)/ -e s/@@GIT_DATE_TIME@@/$(date)/ src/build_version.cc.in
# Record the version of the source that we are compiling.
# We keep a record of the git revision in this file.  It is then built
# as a regular source file as part of the compilation process.
# One can run "strings executable_filename | grep _build_" to find
# the version of the source that we used to build the executable file.
CLEAN_FILES += src/build_version.cc

src/build_version.cc: FORCE
	$(AM_V_GEN)rm -f $@-t
	$(AM_V_at)$(gen_build_version) > $@-t
	$(AM_V_at)if test -f $@; then         \
	  cmp -s $@-t $@ && rm -f $@-t || mv -f $@-t $@;    \
	else mv -f $@-t $@; fi
FORCE: 

LIBOBJECTS = $(LIB_SOURCES:.cc=.o)

# if user didn't config LIBNAME, set the default
ifeq ($(LIBNAME),)
# we should only run nemodb in production with DEBUG_LEVEL 0
ifeq ($(DEBUG_LEVEL),0)
        LIBNAME=libnemodb
else
        LIBNAME=libnemodb_debug
endif
endif
LIBOUTPUT = $(CURDIR)/lib
SRC_PATH = $(CURDIR)/src
dummy := $(shell mkdir -p $(LIBOUTPUT))
LIBRARY = $(LIBOUTPUT)/${LIBNAME}.a

NEMODB_MAJOR = $(shell egrep "NEMODB_MAJOR.[0-9]" include/version.h | cut -d ' ' -f 3)
NEMODB_MINOR = $(shell egrep "NEMODB_MINOR.[0-9]" include/version.h | cut -d ' ' -f 3)
NEMODB_PATCH = $(shell egrep "NEMODB_PATCH.[0-9]" include/version.h | cut -d ' ' -f 3)

#-----------------------------------------------
# Create platform independent shared libraries.
#-----------------------------------------------
ifneq ($(PLATFORM_SHARED_EXT),)

ifneq ($(PLATFORM_SHARED_VERSIONED),true)
SHARED1 = ${LIBNAME}.$(PLATFORM_SHARED_EXT)
SHARED2 = $(SHARED1)
SHARED3 = $(SHARED1)
SHARED4 = $(SHARED1)
SHARED = $(SHARED1)
else
SHARED_MAJOR = $(NEMODB_MAJOR)
SHARED_MINOR = $(NEMODB_MINOR)
SHARED_PATCH = $(NEMODB_PATCH)
SHARED1 = ${LIBNAME}.$(PLATFORM_SHARED_EXT)
ifeq ($(PLATFORM), OS_MACOSX)
SHARED_OSX = $(LIBNAME).$(SHARED_MAJOR)
SHARED2 = $(SHARED_OSX).$(PLATFORM_SHARED_EXT)
SHARED3 = $(SHARED_OSX).$(SHARED_MINOR).$(PLATFORM_SHARED_EXT)
SHARED4 = $(SHARED_OSX).$(SHARED_MINOR).$(SHARED_PATCH).$(PLATFORM_SHARED_EXT)
else
SHARED2 = $(SHARED1).$(SHARED_MAJOR)
SHARED3 = $(SHARED1).$(SHARED_MAJOR).$(SHARED_MINOR)
SHARED4 = $(SHARED1).$(SHARED_MAJOR).$(SHARED_MINOR).$(SHARED_PATCH)
endif
SHARED = $(SHARED1) $(SHARED2) $(SHARED3) $(SHARED4)
$(SHARED1): $(SHARED4)
	ln -fs $(SHARED4) $(SHARED1)
$(SHARED2): $(SHARED4)
	ln -fs $(SHARED4) $(SHARED2)
$(SHARED3): $(SHARED4)
	ln -fs $(SHARED4) $(SHARED3)
endif

$(SHARED4): $(LIBOBJECTS)
	$(CXX) $(PLATFORM_SHARED_LDFLAGS)$(SHARED3) $(CXXFLAGS) $(PLATFORM_SHARED_CFLAGS) $(LIB_SOURCES) \
    $(LDFLAGS) -o $@

endif  # PLATFORM_SHARED_EXT

.PHONY: clean dbg static_lib shared_lib all example

EXAMPLES = examples benchmark

all: $(LIBRARY)

static_lib: $(LIBRARY)

shared_lib: $(SHARED)
	for f in $(notdir $(SHARED)); do mv "$$f" $(LIBOUTPUT); done

LIBROCKSDB=$(ROCKSDB_PATH)/librocksdb.a

example: $(LIBROCKSDB) $(LIBRARY) $(EXAMPLES)

examples: example/examples.o $(LIBOBJECTS)
	$(AM_LINK)

benchmark: example/benchmark.o $(LIBOBJECTS)
	$(AM_LINK)

$(LIBROCKSDB):
	make -j 24 -C $(ROCKSDB_PATH) static_lib

dbg: $(LIBRARY) $(EXAMPLES)

$(LIBRARY): $(LIBOBJECTS)
	$(AM_V_AR)rm -f $@
	$(AM_V_at)$(AR) $(ARFLAGS) $@ $(LIBOBJECTS)

clean:
	make -C ./example clean
	rm -rf $(EXAMPLES)
	rm -f $(LIBRARY) $(SHARED)
	rm -rf $(CLEAN_FILES)
	rm -rf $(LIBOUTPUT)
	find $(SRC_PATH) -name "*.[oda]" -exec rm -f {} \;
	find $(SRC_PATH) -type f -regex ".*\.\(\(gcda\)\|\(gcno\)\)" -exec rm {} \;

.cc.o:
	$(AM_V_CC)$(CXX) $(CXXFLAGS) -c $< -o $@ $(COVERAGEFLAGS)

.c.o:
	$(AM_V_CC)$(CC) $(CFLAGS) -c $< -o $@
